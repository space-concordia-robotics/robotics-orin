import {AfterViewInit, Component, EventEmitter, OnInit, Output, ViewChild} from '@angular/core';
import {MatDialogContent, MatDialogRef, MatDialogTitle} from "@angular/material/dialog";
import {
  MatCell, MatCellDef,
  MatColumnDef,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow, MatHeaderRowDef,
  MatRow, MatRowDef,
  MatTable
} from "@angular/material/table";
import {MatError, MatFormField, MatInput} from "@angular/material/input";
import {
  FormArray,
  FormBuilder,
  FormControl,
  FormGroup,
  FormGroupDirective,
  NgForm,
  ReactiveFormsModule,
  Validators
} from "@angular/forms";
import {MatLabel} from "@angular/material/form-field";
import { MatTableDataSource } from '@angular/material/table';
import {ErrorStateMatcher} from "@angular/material/core";
import {NgForOf} from "@angular/common";
import {MatIconButton} from "@angular/material/button";
import {MatIcon} from "@angular/material/icon";
import {CdkCellDef, CdkColumnDef, CdkHeaderCellDef, CdkHeaderRowDef, CdkRowDef} from "@angular/cdk/table";
import {MatDivider} from "@angular/material/divider";
import * as events from "node:events";
import {CoordinateService} from "../services/coordinate-service";


//Regexes generated by ChatGPT, to match real numbers between a range (such as -90 to 90), and reject any character in the string

//I could tell you what these mean, but I won't. Too bad !
const LatitudeInputMatcherRegex = "^-?(?:90(?:\\.0+)?|[1-8]?\\d(?:\\.\\d+)?|0(?:\\.\\d+)?)$"
const LongitudeInputMatcherRegex = "^-?(?:180(?:\\.0+)?|[1-8]?\\d(?:\\.\\d+)?|0(?:\\.\\d+)?)$"

export class MyErrorStateMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
    const isSubmitted = form && form.submitted;
    return !!(control && control.invalid && (control.dirty || control.touched || isSubmitted));
  }
}
enum CoordinateState{
  INACTIVE,
  QUEUED,
  FINISHED
}
export interface Coordinates{
  latitude : number,
  longitude : number,
  status : CoordinateState
}
@Component({
  selector: 'app-coordinate-manager',
  standalone: true,
  imports: [
    MatDialogContent,
    MatDialogTitle,
    MatHeaderRow,
    MatCell,
    MatRow,
    MatHeaderCell,
    MatColumnDef,
    MatTable,
    MatHeaderCellDef,
    MatCellDef,
    MatHeaderRowDef,
    MatRowDef,
    MatInput,
    ReactiveFormsModule,
    MatFormField,
    MatLabel,
    MatError,
    NgForOf,
    MatIconButton,
    MatIcon,
    CdkRowDef,
    CdkHeaderRowDef,
    CdkColumnDef,
    CdkHeaderCellDef,
    CdkCellDef,
    MatDivider
  ],
  templateUrl: './coordinate-manager.component.html',
  styleUrl: './coordinate-manager.component.css'
})

export class CoordinateManagerComponent implements OnInit,AfterViewInit{
  displayedColumns: string[] = ['latitude', 'longitude', 'status', 'modify', 'delete'];

  @ViewChild(MatTable) table: MatTable<any>;

  coordinates : Coordinates[]
  coordsForm : FormGroup
  matcher = new MyErrorStateMatcher();

  getRows(){
    return this.coordsForm.get('rows') as FormArray
  }
  constructor(private formBuilder:FormBuilder, private coordinateService : CoordinateService) {
    this.coordinates = []
    // Initialize the coordinate forms
    this.coordsForm = this.formBuilder.group({
      rows : this.formBuilder.array([]),
    })
  }
  ngOnInit() {
    let storedCoordinates = JSON.parse(this.coordinateService.coordinates_value.value!!)
    if(storedCoordinates != null){
      this.coordinates = storedCoordinates
      console.log(this.coordinates)
    }
    // We add the 'empty' form, basically a form in which the user just inputs coordinate info.
    this.addEmptyForm()
    this.fillCoordinateForms()

  }
  ngAfterViewInit() {
      this.table.renderRows()
  }

  addEmptyForm(){
     this.getRows().push(
        this.formBuilder.group({
          latitude : new FormControl(45.496082,
      [Validators.required, Validators.pattern(LatitudeInputMatcherRegex)]),
          longitude : new FormControl(-73.569916,
      [Validators.required, Validators.pattern(LongitudeInputMatcherRegex)])
        })
    )
    this.coordinates.unshift({
      latitude : 0,
      longitude : 0,
      status : CoordinateState.INACTIVE
    })
  }
   fillCoordinateForms(){
    console.log(this.coordinates)
    this.getRows().clear()
    for (const coordinateElement of this.coordinates) {
      let formGroup = this.formBuilder.group({
          latitude : new FormControl(coordinateElement.latitude,
      [Validators.required, Validators.pattern(LatitudeInputMatcherRegex)]),
          longitude : new FormControl(coordinateElement.longitude,
      [Validators.required, Validators.pattern(LongitudeInputMatcherRegex)])
        })
      if(coordinateElement.status == CoordinateState.QUEUED){
       formGroup.disable()
      }
      this.getRows().push(formGroup)
     }
  }

  addCoordinates(index : number){
    console.log('Adding coordinates...')
    let formControl = this.getRows().at(index)

    console.log(this.coordinates.at(index))

    let coordinates : Coordinates = {
      latitude : parseFloat(formControl.get('latitude')?.getRawValue()),
      longitude : parseFloat(formControl.get('longitude')?.getRawValue()),
      status : CoordinateState.QUEUED
    }
    // console.log(index)
    if(formControl.invalid){
      console.log(`Invalid input for ${formControl}`)
      return
    }
    // If the coordinate was already queued, it means an update is happening, hence no need to push in the array
    if(this.coordinates.at(index)?.status == CoordinateState.QUEUED){
      this.coordinates[index] = coordinates
    }
    // Push new coordinate to the array
    else {
      this.coordinates.push(coordinates)
    }
    // The slice is needed so the first element (which contains the 'empty' form) is not added to the storage
    // localStorage.setItem("gps_coordinates", JSON.stringify(this.coordinates.slice(1, this.coordinates.length)))
    this.coordinateService.coordinates = JSON.stringify(this.coordinates.slice(1, this.coordinates.length))
    // Calling this will update the table to reflect the new changes
    this.ngOnInit()
  }

  // When a coordinate is modified, the form for it should be enabled.
  modifyCoordinates(index : number){
    if(index == 0) return
    this.getRows().at(index).enable()
  }
  deleteCoordinate(index : number){
    // If the user tries to delete the 'empty' form, prevent that
    if(index == 0) return
    // Using splice for this will resize the array depending on where the element is deleted.
    // For example, assuming index = 2, we get [X1 X2 X3 X4 X5] -> [X1 X2 X4 X5]
    this.coordinates.splice(index,1)
    this.coordinateService.coordinates = JSON.stringify(this.coordinates.slice(1, this.coordinates.length))
    this.ngOnInit()
  }
}
